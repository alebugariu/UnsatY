/*******************************************************************************
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *   
 * Copyright (c) 2021-2023 ETH Zurich.
 *******************************************************************************/
package quantvar;

import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.microsoft.z3.Expr;

import util.Setup;
import util.Verbal_Output;

/*
 * This class is used to collect all the info about a quantified variable
 * appearing in an unsat-proof generated by Vampire that is not included in a
 * Quant_Var object.
 */

public class Vampire_Quant_Var extends Quant_Var {

	// Name of this quantified variable in the unsat-proof generated by Vampire.
	// Is provided in the constructor.
	private String vampire_name;
	// Example: X0.

	protected String get_vampire_name() {
		return vampire_name;
	}

	// Type of this quantified variable in the unsat-proof generated by Vampire.
	// Is provided in the constructor.
	private String vampire_type;

	protected String get_vampire_type() {
		return vampire_type;
	}

	// Indicator whether this Quant_Var object is actually a Vampire_Quant_Var
	// object. Returns true if this is a Vampire_Quant_Var object.
	protected Boolean is_vampire_quant_var() {
		// Since this is the case, we just return true.
		return true;
	}

	List<String> line_numbers;

	// The constructor expects the corresponding Quant_Var object created by the
	// input_reader to set up all the non-Vampire-related fields in this.
	protected Vampire_Quant_Var(Quant_Var z3_quant_var, String vampire_name, String vampire_type, String line_number) {
		super(z3_quant_var);
		this.vampire_name = vampire_name;
		this.vampire_type = vampire_type;
		this.line_numbers = new LinkedList<String>();
		line_numbers.add(line_number);
	}

	// *****************************************************************************

	// *****************************************************************************
	// Proof-related methods.

	protected Boolean contains_line_number(String line_number) {
		if (line_numbers.contains(line_number)) {
			return true;
		}
		return false;
	}

	protected void add_concrete_value_from_function_application(Expr<?> function_application,
			Verbal_Output verbal_output) {
		for (Set<Expr<?>> applications : function_applications_with_quantified_variables.values()) {
			for (Expr<?> application : applications) {
				// Since our quantified variable may be in a nested expression, we want to track
				// the "path" we take through the application on our way towards it. We do this
				// by memorizing the index (in the arguments of the current expression) of each
				// sub-expression we "dive" into.
				List<Integer> tracking_indexes = new LinkedList<Integer>();
				if (!Setup.testing_environment) {
					verbal_output.add_to_buffer("[INFO]",
							"Looking for the quantified variable " + get_name() + " in " + application + ".");
				}
				if (!track_function_applications_until_quantified_variable(get_name().toString(), application,
						tracking_indexes)) {
					if (!Setup.testing_environment) {
						verbal_output.add_to_buffer("[PROBLEM]", "Failed to find the quantified variable " + get_name()
								+ " in the function application.");
					}
					continue;
				}
				// We then take the very same "path" in the function_application to find the
				// corresponding concrete value.
				if (!Setup.testing_environment) {
					verbal_output.add_to_buffer("[INFO]",
							"Looking for the concrete value corresponding to the quantified variable " + get_name()
									+ " in " + function_application + ".");
				}
				if (!repeat_function_applications_until_concrete_value(function_application, tracking_indexes)) {
					if (!Setup.testing_environment) {
						verbal_output.add_to_buffer("[PROBLEM]",
								"Failed tracking: Did not find a suitable concrete value where expected.");
					}
				}
			}
		}
	}

	private Boolean track_function_applications_until_quantified_variable(String name, Expr<?> current_expression,
			List<Integer> tracking_indexes) {
		if (current_expression.isConst() && current_expression.toString().equals(name)) {
			// If the current_expression is a constant that has the same name as the
			// quantified variable, we can return true since tracking_indexes contains
			// all the information we need to reconstruct the path we used to get here.
			return true;
		} else if (current_expression.isApp()) {
			// If the current_expression is an application, it is definitely no constant but
			// the constant we are looking for may be somewhere in its arguments, which we
			// therefore recursively look at.
			Expr<?>[] arguments = current_expression.getArgs();
			for (int i = 0; i < arguments.length; i++) {
				tracking_indexes.add(i);
				if (track_function_applications_until_quantified_variable(name, arguments[i], tracking_indexes)) {
					// If this recursive call returns true, then we found our constant and
					// tracking_indexes contains all the information we need to reconstruct the path
					// we used to get there.
					return true;
				}
				tracking_indexes.remove(tracking_indexes.size() - 1);
			}
		}
		// If we reach this part of the code, then we didn't find our constant.
		return false;
	}

	private Boolean repeat_function_applications_until_concrete_value(Expr<?> current_expression,
			List<Integer> tracking_indexes) {
		if (tracking_indexes.isEmpty() || !current_expression.isApp()) {
			// If tracking_indexes is empty, then we should have reached our goal. That is,
			// the current_expression should be a concrete value that matches the
			// type of the quantified variable. However, it can also happen that
			// tracking_indexes is not yet empty, even though we cannot "dive" deeper into
			// the current_expression (since it is not an application). To get around this
			// problem, we just assume that we have reached our concrete value anyway and
			// check if the current_expression matches the type.
			if (current_expression.getSort().equals(get_type())) {
				// If that's the case, we just found our pair of quantified variable and
				// concrete value.
				add_concrete_value(current_expression);
				return true;
			} else {
				// If that's not the case, then our tracking failed.
				return false;
			}
		} else {
			// If there is another entry in tracking_indexes and we are able to do so, then
			// we "dive" further into the sub_expression of the current_expression indexed
			// by that entry if that's possible.
			int next_index = tracking_indexes.remove(0);
			Expr<?>[] sub_expressions = current_expression.getArgs();
			if (sub_expressions.length > next_index) {
				return repeat_function_applications_until_concrete_value(sub_expressions[next_index], tracking_indexes);
			} else {
				return false;
			}
		}
	}

	// *****************************************************************************

	// *****************************************************************************
	// Pretty print method.

	@Override
	protected String print_instantiation() {
		String out = "[INFO] The quantified variable " + vampire_name + " of sort " + vampire_type
				+ " corresponds to the quantified variable " + get_name() + " from the input.\n";
		if (concrete_values.size() > 0) {
			out += "[INFO] Found the following instantiations for this quantified variable: "
					+ concrete_values.toString() + "\n";
		}
		return out;
	}

	// *****************************************************************************
}
