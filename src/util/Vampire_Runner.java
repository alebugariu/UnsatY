/*******************************************************************************
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *   
 * Copyright (c) 2021-2023 ETH Zurich.
 *******************************************************************************/
package util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

import proof_analyser.unsat_proof.Vampire_Unsat_Proof;
import util.Verbal_Output.Log_Type;

/*
 * This class is used to run Vampire over the command line.
 */

public class Vampire_Runner {

	// Uses Vampire to prove the unsatisfiability of the the input_file.
	public static Vampire_Unsat_Proof run_vampire(File input_file, Set<String> vampire_names, Verbal_Output verbal_output)
			throws Proof_Exception {
		try {
			// First, we set up the list that we want to store the proof in.
			List<String> vampire_proof = new LinkedList<String>();
			// Then, we prepare to call Vampire. For this we create a process to interact
			// with the command line. But first, we have to allow Vampire to be executed.
			Process process = Runtime.getRuntime().exec("chmod u+x " + "./lib" + File.separator + "vampire.4");
			process.waitFor();
			process = Runtime.getRuntime()
					.exec("./lib" + File.separator + "vampire.4 --input_syntax smtlib2 --time_limit "
							+ Setup.vampire_timeout + "s --memory_limit " + Setup.vampire_memory_limit + " "
							+ input_file.getAbsolutePath());
			// We use a BufferedReader to consume the input stream generated by the process.
			BufferedReader standard_input = new BufferedReader(new InputStreamReader(process.getInputStream()));
			Boolean success = false;
			String line = standard_input.readLine();
			while (line != null) {
				if (!line.startsWith("%")) {
					vampire_proof.add(String_Utility.devampirize(line, vampire_names));
				} else if (check_success(line, verbal_output)) {
					success = true;
				}
				line = standard_input.readLine();
			}
			// Wait for Vampire to finish.
			int exit_code = process.waitFor();
			// If we were successful, then we return the proof list.
			if (exit_code == 0) {
				if (success) {
					return new Vampire_Unsat_Proof(vampire_proof);
				} else {
					if (Setup.log_type == Log_Type.full) {
						verbal_output.add_to_buffer("[PROBLEM]",
								"The Vampire unsat-proof does not contain the expected success line.");
					}
				}
			} else if (exit_code != 0) {
				if (Setup.log_type == Log_Type.full) {
					verbal_output.add_to_buffer("[PROBLEM]", "The Vampire process for proving " + input_file.toString()
							+ " returned the exit code: " + exit_code + ".");
				}
			}
		} catch (IOException e) {
			if (Setup.log_type == Log_Type.full) {
				verbal_output.add_to_buffer("[PROBLEM]", "Failed to run Vampire due to some I/O-related problem.");
				verbal_output.add_to_buffer("[PROBLEM]", e.getMessage());
				verbal_output.add_all_to_buffer("\t", e.getStackTrace());
			}
		} catch (InterruptedException e) {
			if (Setup.log_type == Log_Type.full) {
				verbal_output.add_to_buffer("[PROBLEM]", "Failed to run Vampire due to some process-related problem.");
				verbal_output.add_to_buffer("[PROBLEM]", e.getMessage());
				verbal_output.add_all_to_buffer("\t", e.getStackTrace());
			}
		}
		// If we were unsuccessful, then we will reach this part of the method and throw
		// a Proof_Exception.
		Exception_Handler.throw_proof_exception("Failed to run Vampire for " + input_file, verbal_output);
		return null;
	}

	// Checks whether Vampire was successful, i.e. inspects the line to
	// determine whether it states that the unsatisfiability was proven.
	private static Boolean check_success(String line, Verbal_Output verbal_output) {
		String success = "Termination reason: Refutation";
		if (line.contains(success)) {
			return true;
		}
		return false;
	}

	// Uses Vampire to translate the string representation of the input line from
	// the Z3 API to Vampire syntax. To do this, we create a dummy input file that
	// does not contain anything else and from whose unsat-proof we can thus read
	// out the translation.
	// Returns this translated input line.
	public static String translate_to_vampire(File input_file, String input_line, Set<String> vampire_names,
			Verbal_Output verbal_output) throws Proof_Exception {
		try {
			// First we need to create a file containing only the given input line and the
			// necessary definitions.
			String translation_input_file_path = "temp" + File.separator + "vampire_single_input_line.smt2";
			File translation_input_file = new File(translation_input_file_path);
			if (!translation_input_file.createNewFile()) {
				translation_input_file.delete();
				translation_input_file.createNewFile();
			}
			PrintStream translation_input_printer = new PrintStream(translation_input_file);
			// First of all, we need to provide all the function declarations that may
			// appear in the quantifier.
			Scanner scanner = new Scanner(input_file);
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line.contains("(declare-")) {
					translation_input_printer.println(line);
				}
			}
			scanner.close();
			// Next, we have our single input line that we actually want to translate.
			// Since this single input line may not lead to a contradiction, we also have to
			// add some dummy part to ensure the unsatisfiability of the input. We
			// concretely do that by making a conjunction of the input line and "false".
			// Otherwise, Vampire will have difficulties with trying to prove this input.
			translation_input_printer.println("(assert (and " + input_line + " false))");
			translation_input_printer.close();
			List<String> translation_proof = run_vampire(translation_input_file, vampire_names, verbal_output).getLines();
			// Now, we look for our translated quantifier in the translation_proof.
			for (String line : translation_proof) {
				if (line.contains("[input]")) {
					String simplified_line = String_Utility.simplify_preprocessing_line(line);
					// There will be exactly one line in the translation_proof that contain the
					// substring "[input]", namely the one we created above.
					// We still need to remove the "& false" part at the end.
					simplified_line = simplified_line.substring(0, simplified_line.length() - 7);
					// If we were successful, then we return the translated quantifier.
					return simplified_line;
				}
			}
		} catch (IOException e) {
			if (Setup.log_type == Log_Type.full) {
				verbal_output.add_to_buffer("[PROBLEM]",
						"Failed to use Vampire to translate some input line due to some I/O-related problem.");
				verbal_output.add_to_buffer("[PROBLEM]", e.getMessage());
				verbal_output.add_all_to_buffer("\t", e.getStackTrace());
			}
		} catch (Proof_Exception e) {
			// Do nothing, since the reason for the Proof_Exception has already been
			// printed.
		}
		// If we were unsuccessful, then we will reach this part of the method and throw
		// a Proof_Exception.
		Exception_Handler.throw_proof_exception(
				"Vampire failed to translate the input line " + input_line.toString() + ".", verbal_output);
		return null;
	}
}